<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>关于aPaaS平台的思考 | 老东叔写代码</title>
<meta name=keywords content="aPaaS"><meta name=description content="什么是Builder Builder scope划分我的认知里，是从前端视角产生的，基于组件编辑产生DSL，并且解析DSL产出页面。
从一个更中立的视角来看，其实这是两件事，IDE与运行容器。而这两者之间，隐含了一个不被重视的服务端工作，就是DSL的持久化与维护。
产品演进 前身是kunlun 我们是服务B端的，少数大客户的边缘Case也是要处理的，或者说很重要 我们曾经在两个路径里摇摆，服务字节还是搞好商业化 这一年的主题，删繁就简 支持了电商，但又抛弃了电商 6月接客 前端演进 1.0 2.0 3.0
没法纠结技术细节，前端内容不是很懂，投入研究的ROI太低了。
技术现状 由于之前一直没有服务端团队，所以所有的资料都是从前端视角来做的。尽快完成一份服务端的梳理与规划文档十分关键
设计态 核心问题，一个页面有哪些信息来描述，保存在哪里
从PageConfig的存在，可以初步总结Builder的服务端在这里有两个核心职责：
数据的持久化，未来的协同编辑，增量存储等
IDE的体验支持（既然叫IDE，有什么是本地解决不了的，我在把自己越做越薄？）
基于现有的资料：
页面=基本信息+UIDL+Page Config
基本信息：页面的标题描述等
UIDL：对页面内容的定义
Page Config：服务端需要感知的内容，导航信息，权限树，多语言，环境变量等。
我的问题：
这个划分逻辑是否合理，Page Config看起来更像是Index，用来辅助IDE运行提示。是否应该影响页面本身的定义与组织
写入时机是否合理，page config的实时性要求是什么样的。检索UIDL生产page config保存的设计是否合理。
如果UIDL只能全量保存，就不应当支持并发编辑。进一步的page config的开发辅助功能可以本地进行。为什么要向服务端投递。
Builder DSL希望在一份文件内包含页面所有的表达，实质上已经弱化了Page Config的功能，一个IDE的Index使用应当影响主流程性能。应当向旁路转移
但以上更多的是基于存储视角的逻辑，设计态应该进行什么样的表达，元素有哪些没有进行完整的讨论。
类型
位置 或者说 层级
属性
行为 这里包含 数据关联
“编译” 在设计态完成设计，与运行态执行之间，服务端可以做什么
这个是我们可以摆脱前端做的，或者说前端做不了的。在这两个环节之间，前端没有任何实体。
Builder DSL的“编译期优化”
时效性上，当前的产品设计上，发布流程会给服务端多少时间与空间。
服务端直接渲染出HTML+JS的代码不是更强，有没有办法做0成本抽象
必须找到实际可解决的问题。好好深入一下运行态的问题。
ByteFX编译耗时很慢，目前被前置到了设计态触发。这部分算力成本的转移是否合理呢 Glad方案，是否优雅 运行态 通过下发设计态的产物，让App跑起来
阶段目标 明确业务边界
我们在做什么，要做什么
Prove我们自己的价值，之前只有前端也能运转，我们7个的价值是什么
关联业务方 谁为我们提供了什么样的支持，我们之间的边界是啥
各种Gateway
RefService：metadata服务中的另一个模块，mt_ref表中记录了页面对元数据的引用关系"><meta name=author content="jiandong.liu93"><link rel=canonical href=https://meepoljd.github.io/posts/what-is-apaas/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://meepoljd.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://meepoljd.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://meepoljd.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://meepoljd.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://meepoljd.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="关于aPaaS平台的思考"><meta property="og:description" content="什么是Builder Builder scope划分我的认知里，是从前端视角产生的，基于组件编辑产生DSL，并且解析DSL产出页面。
从一个更中立的视角来看，其实这是两件事，IDE与运行容器。而这两者之间，隐含了一个不被重视的服务端工作，就是DSL的持久化与维护。
产品演进 前身是kunlun 我们是服务B端的，少数大客户的边缘Case也是要处理的，或者说很重要 我们曾经在两个路径里摇摆，服务字节还是搞好商业化 这一年的主题，删繁就简 支持了电商，但又抛弃了电商 6月接客 前端演进 1.0 2.0 3.0
没法纠结技术细节，前端内容不是很懂，投入研究的ROI太低了。
技术现状 由于之前一直没有服务端团队，所以所有的资料都是从前端视角来做的。尽快完成一份服务端的梳理与规划文档十分关键
设计态 核心问题，一个页面有哪些信息来描述，保存在哪里
从PageConfig的存在，可以初步总结Builder的服务端在这里有两个核心职责：
数据的持久化，未来的协同编辑，增量存储等
IDE的体验支持（既然叫IDE，有什么是本地解决不了的，我在把自己越做越薄？）
基于现有的资料：
页面=基本信息+UIDL+Page Config
基本信息：页面的标题描述等
UIDL：对页面内容的定义
Page Config：服务端需要感知的内容，导航信息，权限树，多语言，环境变量等。
我的问题：
这个划分逻辑是否合理，Page Config看起来更像是Index，用来辅助IDE运行提示。是否应该影响页面本身的定义与组织
写入时机是否合理，page config的实时性要求是什么样的。检索UIDL生产page config保存的设计是否合理。
如果UIDL只能全量保存，就不应当支持并发编辑。进一步的page config的开发辅助功能可以本地进行。为什么要向服务端投递。
Builder DSL希望在一份文件内包含页面所有的表达，实质上已经弱化了Page Config的功能，一个IDE的Index使用应当影响主流程性能。应当向旁路转移
但以上更多的是基于存储视角的逻辑，设计态应该进行什么样的表达，元素有哪些没有进行完整的讨论。
类型
位置 或者说 层级
属性
行为 这里包含 数据关联
“编译” 在设计态完成设计，与运行态执行之间，服务端可以做什么
这个是我们可以摆脱前端做的，或者说前端做不了的。在这两个环节之间，前端没有任何实体。
Builder DSL的“编译期优化”
时效性上，当前的产品设计上，发布流程会给服务端多少时间与空间。
服务端直接渲染出HTML+JS的代码不是更强，有没有办法做0成本抽象
必须找到实际可解决的问题。好好深入一下运行态的问题。
ByteFX编译耗时很慢，目前被前置到了设计态触发。这部分算力成本的转移是否合理呢 Glad方案，是否优雅 运行态 通过下发设计态的产物，让App跑起来
阶段目标 明确业务边界
我们在做什么，要做什么
Prove我们自己的价值，之前只有前端也能运转，我们7个的价值是什么
关联业务方 谁为我们提供了什么样的支持，我们之间的边界是啥
各种Gateway
RefService：metadata服务中的另一个模块，mt_ref表中记录了页面对元数据的引用关系"><meta property="og:type" content="article"><meta property="og:url" content="https://meepoljd.github.io/posts/what-is-apaas/"><meta property="og:image" content="https://meepoljd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-20T19:11:14+08:00"><meta property="article:modified_time" content="2024-03-20T19:11:14+08:00"><meta property="og:site_name" content="老东叔写代码"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://meepoljd.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="关于aPaaS平台的思考"><meta name=twitter:description content="什么是Builder Builder scope划分我的认知里，是从前端视角产生的，基于组件编辑产生DSL，并且解析DSL产出页面。
从一个更中立的视角来看，其实这是两件事，IDE与运行容器。而这两者之间，隐含了一个不被重视的服务端工作，就是DSL的持久化与维护。
产品演进 前身是kunlun 我们是服务B端的，少数大客户的边缘Case也是要处理的，或者说很重要 我们曾经在两个路径里摇摆，服务字节还是搞好商业化 这一年的主题，删繁就简 支持了电商，但又抛弃了电商 6月接客 前端演进 1.0 2.0 3.0
没法纠结技术细节，前端内容不是很懂，投入研究的ROI太低了。
技术现状 由于之前一直没有服务端团队，所以所有的资料都是从前端视角来做的。尽快完成一份服务端的梳理与规划文档十分关键
设计态 核心问题，一个页面有哪些信息来描述，保存在哪里
从PageConfig的存在，可以初步总结Builder的服务端在这里有两个核心职责：
数据的持久化，未来的协同编辑，增量存储等
IDE的体验支持（既然叫IDE，有什么是本地解决不了的，我在把自己越做越薄？）
基于现有的资料：
页面=基本信息+UIDL+Page Config
基本信息：页面的标题描述等
UIDL：对页面内容的定义
Page Config：服务端需要感知的内容，导航信息，权限树，多语言，环境变量等。
我的问题：
这个划分逻辑是否合理，Page Config看起来更像是Index，用来辅助IDE运行提示。是否应该影响页面本身的定义与组织
写入时机是否合理，page config的实时性要求是什么样的。检索UIDL生产page config保存的设计是否合理。
如果UIDL只能全量保存，就不应当支持并发编辑。进一步的page config的开发辅助功能可以本地进行。为什么要向服务端投递。
Builder DSL希望在一份文件内包含页面所有的表达，实质上已经弱化了Page Config的功能，一个IDE的Index使用应当影响主流程性能。应当向旁路转移
但以上更多的是基于存储视角的逻辑，设计态应该进行什么样的表达，元素有哪些没有进行完整的讨论。
类型
位置 或者说 层级
属性
行为 这里包含 数据关联
“编译” 在设计态完成设计，与运行态执行之间，服务端可以做什么
这个是我们可以摆脱前端做的，或者说前端做不了的。在这两个环节之间，前端没有任何实体。
Builder DSL的“编译期优化”
时效性上，当前的产品设计上，发布流程会给服务端多少时间与空间。
服务端直接渲染出HTML+JS的代码不是更强，有没有办法做0成本抽象
必须找到实际可解决的问题。好好深入一下运行态的问题。
ByteFX编译耗时很慢，目前被前置到了设计态触发。这部分算力成本的转移是否合理呢 Glad方案，是否优雅 运行态 通过下发设计态的产物，让App跑起来
阶段目标 明确业务边界
我们在做什么，要做什么
Prove我们自己的价值，之前只有前端也能运转，我们7个的价值是什么
关联业务方 谁为我们提供了什么样的支持，我们之间的边界是啥
各种Gateway
RefService：metadata服务中的另一个模块，mt_ref表中记录了页面对元数据的引用关系"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://meepoljd.github.io/posts/"},{"@type":"ListItem","position":2,"name":"关于aPaaS平台的思考","item":"https://meepoljd.github.io/posts/what-is-apaas/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"关于aPaaS平台的思考","name":"关于aPaaS平台的思考","description":"什么是Builder Builder scope划分我的认知里，是从前端视角产生的，基于组件编辑产生DSL，并且解析DSL产出页面。\n从一个更中立的视角来看，其实这是两件事，IDE与运行容器。而这两者之间，隐含了一个不被重视的服务端工作，就是DSL的持久化与维护。\n产品演进 前身是kunlun 我们是服务B端的，少数大客户的边缘Case也是要处理的，或者说很重要 我们曾经在两个路径里摇摆，服务字节还是搞好商业化 这一年的主题，删繁就简 支持了电商，但又抛弃了电商 6月接客 前端演进 1.0 2.0 3.0\n没法纠结技术细节，前端内容不是很懂，投入研究的ROI太低了。\n技术现状 由于之前一直没有服务端团队，所以所有的资料都是从前端视角来做的。尽快完成一份服务端的梳理与规划文档十分关键\n设计态 核心问题，一个页面有哪些信息来描述，保存在哪里\n从PageConfig的存在，可以初步总结Builder的服务端在这里有两个核心职责：\n数据的持久化，未来的协同编辑，增量存储等\nIDE的体验支持（既然叫IDE，有什么是本地解决不了的，我在把自己越做越薄？）\n基于现有的资料：\n页面=基本信息+UIDL+Page Config\n基本信息：页面的标题描述等\nUIDL：对页面内容的定义\nPage Config：服务端需要感知的内容，导航信息，权限树，多语言，环境变量等。\n我的问题：\n这个划分逻辑是否合理，Page Config看起来更像是Index，用来辅助IDE运行提示。是否应该影响页面本身的定义与组织\n写入时机是否合理，page config的实时性要求是什么样的。检索UIDL生产page config保存的设计是否合理。\n如果UIDL只能全量保存，就不应当支持并发编辑。进一步的page config的开发辅助功能可以本地进行。为什么要向服务端投递。\nBuilder DSL希望在一份文件内包含页面所有的表达，实质上已经弱化了Page Config的功能，一个IDE的Index使用应当影响主流程性能。应当向旁路转移\n但以上更多的是基于存储视角的逻辑，设计态应该进行什么样的表达，元素有哪些没有进行完整的讨论。\n类型\n位置 或者说 层级\n属性\n行为 这里包含 数据关联\n“编译” 在设计态完成设计，与运行态执行之间，服务端可以做什么\n这个是我们可以摆脱前端做的，或者说前端做不了的。在这两个环节之间，前端没有任何实体。\nBuilder DSL的“编译期优化”\n时效性上，当前的产品设计上，发布流程会给服务端多少时间与空间。\n服务端直接渲染出HTML+JS的代码不是更强，有没有办法做0成本抽象\n必须找到实际可解决的问题。好好深入一下运行态的问题。\nByteFX编译耗时很慢，目前被前置到了设计态触发。这部分算力成本的转移是否合理呢 Glad方案，是否优雅 运行态 通过下发设计态的产物，让App跑起来\n阶段目标 明确业务边界\n我们在做什么，要做什么\nProve我们自己的价值，之前只有前端也能运转，我们7个的价值是什么\n关联业务方 谁为我们提供了什么样的支持，我们之间的边界是啥\n各种Gateway\nRefService：metadata服务中的另一个模块，mt_ref表中记录了页面对元数据的引用关系","keywords":["aPaaS"],"articleBody":"什么是Builder Builder scope划分我的认知里，是从前端视角产生的，基于组件编辑产生DSL，并且解析DSL产出页面。\n从一个更中立的视角来看，其实这是两件事，IDE与运行容器。而这两者之间，隐含了一个不被重视的服务端工作，就是DSL的持久化与维护。\n产品演进 前身是kunlun 我们是服务B端的，少数大客户的边缘Case也是要处理的，或者说很重要 我们曾经在两个路径里摇摆，服务字节还是搞好商业化 这一年的主题，删繁就简 支持了电商，但又抛弃了电商 6月接客 前端演进 1.0 2.0 3.0\n没法纠结技术细节，前端内容不是很懂，投入研究的ROI太低了。\n技术现状 由于之前一直没有服务端团队，所以所有的资料都是从前端视角来做的。尽快完成一份服务端的梳理与规划文档十分关键\n设计态 核心问题，一个页面有哪些信息来描述，保存在哪里\n从PageConfig的存在，可以初步总结Builder的服务端在这里有两个核心职责：\n数据的持久化，未来的协同编辑，增量存储等\nIDE的体验支持（既然叫IDE，有什么是本地解决不了的，我在把自己越做越薄？）\n基于现有的资料：\n页面=基本信息+UIDL+Page Config\n基本信息：页面的标题描述等\nUIDL：对页面内容的定义\nPage Config：服务端需要感知的内容，导航信息，权限树，多语言，环境变量等。\n我的问题：\n这个划分逻辑是否合理，Page Config看起来更像是Index，用来辅助IDE运行提示。是否应该影响页面本身的定义与组织\n写入时机是否合理，page config的实时性要求是什么样的。检索UIDL生产page config保存的设计是否合理。\n如果UIDL只能全量保存，就不应当支持并发编辑。进一步的page config的开发辅助功能可以本地进行。为什么要向服务端投递。\nBuilder DSL希望在一份文件内包含页面所有的表达，实质上已经弱化了Page Config的功能，一个IDE的Index使用应当影响主流程性能。应当向旁路转移\n但以上更多的是基于存储视角的逻辑，设计态应该进行什么样的表达，元素有哪些没有进行完整的讨论。\n类型\n位置 或者说 层级\n属性\n行为 这里包含 数据关联\n“编译” 在设计态完成设计，与运行态执行之间，服务端可以做什么\n这个是我们可以摆脱前端做的，或者说前端做不了的。在这两个环节之间，前端没有任何实体。\nBuilder DSL的“编译期优化”\n时效性上，当前的产品设计上，发布流程会给服务端多少时间与空间。\n服务端直接渲染出HTML+JS的代码不是更强，有没有办法做0成本抽象\n必须找到实际可解决的问题。好好深入一下运行态的问题。\nByteFX编译耗时很慢，目前被前置到了设计态触发。这部分算力成本的转移是否合理呢 Glad方案，是否优雅 运行态 通过下发设计态的产物，让App跑起来\n阶段目标 明确业务边界\n我们在做什么，要做什么\nProve我们自己的价值，之前只有前端也能运转，我们7个的价值是什么\n关联业务方 谁为我们提供了什么样的支持，我们之间的边界是啥\n各种Gateway\nRefService：metadata服务中的另一个模块，mt_ref表中记录了页面对元数据的引用关系\nData\nRule\n代码理解 常见的几个隔离级别：\nTenant 租户\nNamespace 命名空间或者说应用？\nLane 泳道？\n元信息指什么，描述页面的都算？\n数据模型\nPageConfig：解除其他模块对组件的配置数据细节的依赖，给其他模块提供一套稳定的协议。在接口中，除domainModel外，其余的的pageConf，服务端均不感知。那为什么还放在一起。\nAPIName/APIID：元数据唯一标识，TenantID+NameSpace内唯一，也就是应用内唯一。\n远景展望 分离设计态运行时的支持信息，index独立维护管理，优化性能，甜点功能从主线分离。同时分离的分析可以更好的融合ai，做低代码的copilot\n设计态运行态之间插入一个编译产物管理。这是前端视角缺失的内容，离开浏览器我们能做什么\n目前我们在推广，卖点是研发效率，但“大销售期”度过后，被征服的开发者会将低码开发的产品投向C端（相对的C）使用，必然会产生运行态C端体验的优化，尽早布局可以提升天花板。\n我们应该更重视编译产物的流转管理，持久化是builder服务端的本源定位。这也是我们的存在价值，提供灰度，ab test等更多能力。\n编译期是用户无感且有明确预期的一个阶段。可以承担大量的计算成本。\n涉及产物与运行产物的分离，这个收益如何论证，强行一直看起来天花板很低，需要前端帮忙论证。\n加了编译期，搞lynx，抖音小程序啥的，都有的玩\n那么有三个域，设计，支撑，分发。\n设计，增量更新，并发编辑，编译优化。专注于保存设计产物，不要再设计期做过度计算\n支撑，索引，ai推荐（我真的觉得有的玩），优化ide性能。各种辅助与ChangeLog。\n分发，编译产物管理，发布，灰度，运行期权限，数据拉取等能力，主要是运行态支持。未来的aPaaS产品的场景扩展性保障\n安全问题，我们提供的能力是否有注入或者其他风险。弄挖矿代码进去怎么算\n架构展望 以上的纯纯是业务理解，那么进一步的怎么去通过业务理解，转换成未来的架构设计。\n杂项 如何论证收益，很关键 我们应该承接起运行时的解析工作，由Builder服务端承担起运行时的动态成本，更可控。让Data等业务沉淀到Builder之后去。\n小程序首屏优化有没有啥积累\n耗时优化做到端到端分析，明确价值\n浏览器限制，比如请求的排队。之前忽略了client的情况。一个之前没讨论过的topic\n小程序首屏优化有没有啥积累\nUIDL是否是可公开的\n网关每次的通过耗时。一个优化点\n计算环节有哪些是应该分配到服务端的，我们作为IDE还能做什么\n协同编辑的OT算法？只有服务端可以做\n本地执行？Or 飞书服务器托管，各自什么逻辑，支不支持开发者植入登录态，还是我们自己支持的。如果是，登录态校验逻辑我们包给开发者？\n如果我们做。我们跟data和auto是啥关系\n","wordCount":"114","inLanguage":"en","datePublished":"2024-03-20T19:11:14+08:00","dateModified":"2024-03-20T19:11:14+08:00","author":[{"@type":"Person","name":"jiandong.liu93"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://meepoljd.github.io/posts/what-is-apaas/"},"publisher":{"@type":"Organization","name":"老东叔写代码","logo":{"@type":"ImageObject","url":"https://meepoljd.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://meepoljd.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://meepoljd.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://meepoljd.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://meepoljd.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://meepoljd.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://meepoljd.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">关于aPaaS平台的思考
<span class=entry-hint title=Draft><svg xmlns="http://www.w3.org/2000/svg" height="35" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h1><div class=post-meta><span title='2024-03-20 19:11:14 +0800 CST'>March 20, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;114 words&nbsp;·&nbsp;jiandong.liu93</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#设计态>设计态</a></li><li><a href=#编译>“编译”</a></li><li><a href=#运行态>运行态</a></li><li><a href=#阶段目标>阶段目标</a></li><li><a href=#关联业务方>关联业务方</a></li><li><a href=#代码理解>代码理解</a></li></ul></nav></div></details></div><div class=post-content><h1 id=什么是builder>什么是Builder<a hidden class=anchor aria-hidden=true href=#什么是builder>#</a></h1><p>Builder scope划分我的认知里，是从前端视角产生的，基于组件编辑产生DSL，并且解析DSL产出页面。</p><p>从一个更中立的视角来看，其实这是两件事，IDE与运行容器。而这两者之间，隐含了一个不被重视的服务端工作，就是DSL的持久化与维护。</p><h1 id=产品演进>产品演进<a hidden class=anchor aria-hidden=true href=#产品演进>#</a></h1><ul><li>前身是kunlun</li><li>我们是服务B端的，少数大客户的边缘Case也是要处理的，或者说很重要</li><li>我们曾经在两个路径里摇摆，服务字节还是搞好商业化</li><li>这一年的主题，删繁就简</li><li>支持了电商，但又抛弃了电商</li><li>6月接客</li></ul><h1 id=前端演进>前端演进<a hidden class=anchor aria-hidden=true href=#前端演进>#</a></h1><ul><li><p>1.0 2.0 3.0</p></li><li><p>没法纠结技术细节，前端内容不是很懂，投入研究的ROI太低了。</p></li></ul><h1 id=技术现状>技术现状<a hidden class=anchor aria-hidden=true href=#技术现状>#</a></h1><blockquote><p>由于之前一直没有服务端团队，所以所有的资料都是从前端视角来做的。尽快完成一份服务端的梳理与规划文档十分关键</p></blockquote><h2 id=设计态>设计态<a hidden class=anchor aria-hidden=true href=#设计态>#</a></h2><blockquote><p>核心问题，一个页面有哪些信息来描述，保存在哪里</p><p>从PageConfig的存在，可以初步总结Builder的服务端在这里有两个核心职责：</p><ol><li><p>数据的持久化，未来的协同编辑，增量存储等</p></li><li><p>IDE的体验支持（既然叫IDE，有什么是本地解决不了的，我在把自己越做越薄？）</p></li></ol></blockquote><p>基于现有的资料：</p><p>页面=基本信息+UIDL+Page Config</p><ol><li><p>基本信息：页面的标题描述等</p></li><li><p>UIDL：对页面内容的定义</p></li><li><p>Page Config：<strong>服务端需要感知的内容</strong>，导航信息，权限树，多语言，环境变量等。</p></li></ol><p>我的问题：</p><ol><li><p>这个划分逻辑是否合理，Page Config看起来更像是Index，用来辅助IDE运行提示。是否应该影响页面本身的定义与组织</p></li><li><p>写入时机是否合理，page config的实时性要求是什么样的。检索UIDL生产page config保存的设计是否合理。</p></li><li><p>如果UIDL只能全量保存，就不应当支持并发编辑。进一步的page config的开发辅助功能可以本地进行。为什么要向服务端投递。</p></li><li><p>Builder DSL希望在一份文件内包含页面所有的表达，实质上已经弱化了Page Config的功能，一个IDE的Index使用应当影响主流程性能。应当向旁路转移</p></li></ol><p>但以上更多的是基于存储视角的逻辑，设计态应该进行什么样的表达，元素有哪些没有进行完整的讨论。</p><ol><li><p>类型</p></li><li><p>位置 或者说 层级</p></li><li><p>属性</p></li><li><p>行为 这里包含 数据关联</p></li></ol><h2 id=编译>“编译”<a hidden class=anchor aria-hidden=true href=#编译>#</a></h2><blockquote><p>在设计态完成设计，与运行态执行之间，服务端可以做什么</p><p>这个是我们可以摆脱前端做的，或者说前端做不了的。在这两个环节之间，前端没有任何实体。</p><p>Builder DSL的“编译期优化”</p><p>时效性上，当前的产品设计上，发布流程会给服务端多少时间与空间。</p><p>服务端直接渲染出HTML+JS的代码不是更强，有没有办法做0成本抽象</p></blockquote><p>必须找到实际可解决的问题。好好深入一下运行态的问题。</p><ol><li>ByteFX编译耗时很慢，目前被前置到了设计态触发。这部分算力成本的转移是否合理呢</li><li>Glad方案，是否优雅</li></ol><h2 id=运行态>运行态<a hidden class=anchor aria-hidden=true href=#运行态>#</a></h2><blockquote><p>通过下发设计态的产物，让App跑起来</p></blockquote><h2 id=阶段目标>阶段目标<a hidden class=anchor aria-hidden=true href=#阶段目标>#</a></h2><ol><li><p>明确业务边界</p></li><li><p>我们在做什么，要做什么</p></li><li><p>Prove我们自己的价值，之前只有前端也能运转，我们7个的价值是什么</p></li></ol><h2 id=关联业务方>关联业务方<a hidden class=anchor aria-hidden=true href=#关联业务方>#</a></h2><blockquote><p>谁为我们提供了什么样的支持，我们之间的边界是啥</p></blockquote><ol><li><p>各种Gateway</p></li><li><p>RefService：metadata服务中的另一个模块，mt_ref表中记录了页面对元数据的引用关系</p></li><li><p>Data</p></li><li><p>Rule</p></li></ol><h2 id=代码理解>代码理解<a hidden class=anchor aria-hidden=true href=#代码理解>#</a></h2><ol><li><p>常见的几个隔离级别：</p><ol><li><p>Tenant 租户</p></li><li><p>Namespace 命名空间或者说应用？</p></li><li><p>Lane 泳道？</p></li></ol></li><li><p>元信息指什么，描述页面的都算？</p></li><li><p>数据模型</p></li><li><p>PageConfig：解除其他模块对组件的配置数据细节的依赖，给其他模块提供一套稳定的协议。在接口中，除domainModel外，其余的的pageConf，服务端均不感知。<strong>那为什么还放在一起。</strong></p></li><li><p>APIName/APIID：元数据唯一标识，TenantID+NameSpace内唯一，也就是应用内唯一。</p></li></ol><h1 id=远景展望>远景展望<a hidden class=anchor aria-hidden=true href=#远景展望>#</a></h1><p>分离设计态运行时的支持信息，index独立维护管理，优化性能，甜点功能从主线分离。同时分离的分析可以更好的融合ai，做低代码的copilot</p><p>设计态运行态之间插入一个编译产物管理。这是前端视角缺失的内容，离开浏览器我们能做什么</p><p>目前我们在推广，卖点是研发效率，但“大销售期”度过后，被征服的开发者会将低码开发的产品投向C端（相对的C）使用，必然会产生运行态C端体验的优化，尽早布局可以提升天花板。</p><p>我们应该更重视编译产物的流转管理，持久化是builder服务端的本源定位。这也是我们的存在价值，提供灰度，ab test等更多能力。</p><p>编译期是用户无感且有明确预期的一个阶段。可以承担大量的计算成本。</p><p>涉及产物与运行产物的分离，这个收益如何论证，强行一直看起来天花板很低，需要前端帮忙论证。</p><p>加了编译期，搞lynx，抖音小程序啥的，都有的玩</p><p>那么有三个域，设计，支撑，分发。</p><p>设计，增量更新，并发编辑，编译优化。专注于保存设计产物，不要再设计期做过度计算</p><p>支撑，索引，<strong>ai推荐（我真的觉得有的玩）</strong>，优化ide性能。各种辅助与ChangeLog。</p><p>分发，编译产物管理，发布，灰度，运行期权限，数据拉取等能力，主要是运行态支持。未来的aPaaS产品的场景扩展性保障</p><p>安全问题，我们提供的能力是否有注入或者其他风险。弄挖矿代码进去怎么算</p><h1 id=架构展望>架构展望<a hidden class=anchor aria-hidden=true href=#架构展望>#</a></h1><blockquote><p>以上的纯纯是业务理解，那么进一步的怎么去通过业务理解，转换成未来的架构设计。</p></blockquote><h1 id=杂项>杂项<a hidden class=anchor aria-hidden=true href=#杂项>#</a></h1><ol><li>如何论证收益，很关键</li></ol><ul><li><p>我们应该承接起运行时的解析工作，由Builder服务端承担起运行时的动态成本，更可控。让Data等业务沉淀到Builder之后去。</p></li><li><p>小程序首屏优化有没有啥积累</p></li></ul><ol start=2><li><p>耗时优化做到端到端分析，明确价值</p></li><li><p>浏览器限制，比如请求的排队。之前忽略了client的情况。一个之前没讨论过的topic</p></li><li><p>小程序首屏优化有没有啥积累</p></li><li><p>UIDL是否是可公开的</p></li><li><p>网关每次的通过耗时。一个优化点</p></li><li><p>计算环节有哪些是应该分配到服务端的，我们作为IDE还能做什么</p></li><li><p>协同编辑的OT算法？只有服务端可以做</p></li><li><p>本地执行？Or 飞书服务器托管，各自什么逻辑，支不支持开发者植入登录态，还是我们自己支持的。如果是，登录态校验逻辑我们包给开发者？</p></li><li><p>如果我们做。我们跟data和auto是啥关系</p></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://meepoljd.github.io/tags/apaas/>aPaaS</a></li></ul><nav class=paginav><a class=prev href=https://meepoljd.github.io/posts/interior-finish/><span class=title>« Prev</span><br><span>装修计划</span>
</a><a class=next href=https://meepoljd.github.io/posts/go-asm/><span class=title>Next »</span><br><span>尝试读懂Go ASM</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://meepoljd.github.io/>老东叔写代码</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>